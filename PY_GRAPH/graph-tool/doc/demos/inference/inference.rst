.. _inference-howto:

Inferring modular network structure
===================================

``graph-tool`` includes algorithms to identify the large-scale structure
of networks in the :mod:`~graph_tool.inference` submodule. Here we
explain the basic functionality with self-contained examples. For a more
thorough theoretical introduction to the methods described here, the
reader is referred to [peixoto-bayesian-2017]_.

Background: Nonparametric statistical inference
-----------------------------------------------

A common task when analyzing networks is to characterize their
structures in simple terms, often by dividing the nodes into modules or
"communities".

A principled approach to perform this task is to formulate `generative
models <https://en.wikipedia.org/wiki/Generative_model>`_ that include
the idea of "modules" in their descriptions, which then can be detected
by `inferring <https://en.wikipedia.org/wiki/Statistical_inference>`_
the model parameters from data. More precisely, given the partition
:math:`\boldsymbol b = \{b_i\}` of the network into :math:`B` groups,
where :math:`b_i\in[0,B-1]` is the group membership of node :math:`i`,
we define a model that generates a network :math:`\boldsymbol G` with a
probability

.. math::
   :label: model-likelihood

   P(\boldsymbol G|\boldsymbol\theta, \boldsymbol b)

where :math:`\boldsymbol\theta` are additional model parameters that
control how the node partition affects the structure of the
network. Therefore, if we observe a network :math:`\boldsymbol G`, the
likelihood that it was generated by a given partition :math:`\boldsymbol
b` is obtained via the `Bayesian
<https://en.wikipedia.org/wiki/Bayesian_inference>`_ posterior

.. math::
   :label: model-posterior-sum

   P(\boldsymbol b | \boldsymbol G) = \frac{\sum_{\boldsymbol\theta}P(\boldsymbol G|\boldsymbol\theta, \boldsymbol b)P(\boldsymbol\theta, \boldsymbol b)}{P(\boldsymbol G)}

where :math:`P(\boldsymbol\theta, \boldsymbol b)` is the `prior
probability <https://en.wikipedia.org/wiki/Prior_probability>`_ of the
model parameters, and

.. math::
   :label: model-evidence

   P(\boldsymbol G) = \sum_{\boldsymbol\theta,\boldsymbol b}P(\boldsymbol G|\boldsymbol\theta, \boldsymbol b)P(\boldsymbol\theta, \boldsymbol b)

is called the `evidence`. The particular types of model that will be
considered here have "hard constraints", such that there is only one
choice for the remaining parameters :math:`\boldsymbol\theta` that is
compatible with the generated network, such that
Eq. :eq:`model-posterior-sum` simplifies to

.. math::
   :label: model-posterior

   P(\boldsymbol b | \boldsymbol G) = \frac{P(\boldsymbol G|\boldsymbol\theta, \boldsymbol b)P(\boldsymbol\theta, \boldsymbol b)}{P(\boldsymbol G)}

with :math:`\boldsymbol\theta` above being the only choice compatible with
:math:`\boldsymbol G` and :math:`\boldsymbol b`. The inference procedures considered
here will consist in either finding a network partition that maximizes
Eq. :eq:`model-posterior`, or sampling different partitions according
its posterior probability.

As we will show below, this approach also enables the comparison of
`different` models according to statistical evidence (a.k.a. `model
selection`).

Minimum description length (MDL)
++++++++++++++++++++++++++++++++

We note that Eq. :eq:`model-posterior` can be written as

.. math::

   P(\boldsymbol b | \boldsymbol G) = \frac{\exp(-\Sigma)}{P(\boldsymbol G)}

where

.. math::
   :label: model-dl

   \Sigma = -\ln P(\boldsymbol G|\boldsymbol\theta, \boldsymbol b) - \ln P(\boldsymbol\theta, \boldsymbol b)

is called the **description length** of the network :math:`\boldsymbol
G`. It measures the amount of `information
<https://en.wikipedia.org/wiki/Information_theory>`_ required to
describe the data, if we `encode
<https://en.wikipedia.org/wiki/Entropy_encoding>`_ it using the
particular parametrization of the generative model given by
:math:`\boldsymbol\theta` and :math:`\boldsymbol b`, as well as the
parameters themselves. Therefore, if we choose to maximize the posterior
distribution of Eq. :eq:`model-posterior` it will be fully equivalent to
the so-called `minimum description length
<https://en.wikipedia.org/wiki/Minimum_description_length>`_
method. This approach corresponds to an implementation of `Occam's razor
<https://en.wikipedia.org/wiki/Occam%27s_razor>`_, where the `simplest`
model is selected, among all possibilities with the same explanatory
power. The selection is based on the statistical evidence available, and
therefore will not `overfit
<https://en.wikipedia.org/wiki/Overfitting>`_, i.e. mistake stochastic
fluctuations for actual structure. In particular this means that we will
not find modules in networks if they could have arisen simply because of
stochastic fluctuations, as they do in fully random graphs
[guimera-modularity-2004]_.

The stochastic block model (SBM)
--------------------------------

The `stochastic block model
<https://en.wikipedia.org/wiki/Stochastic_block_model>`_ is arguably
the simplest generative process based on the notion of groups of
nodes [holland-stochastic-1983]_. The `microcanonical
<https://en.wikipedia.org/wiki/Microcanonical_ensemble>`_ formulation
[peixoto-nonparametric-2017]_ of the basic or "traditional" version takes
as parameters the partition of the nodes into groups
:math:`\boldsymbol b` and a :math:`B\times B` matrix of edge counts
:math:`\boldsymbol e`, where :math:`e_{rs}` is the number of edges
between groups :math:`r` and :math:`s`. Given these constraints, the
edges are then placed randomly. Hence, nodes that belong to the same
group possess the same probability of being connected with other
nodes of the network.

An example of a possible parametrization is given in the following
figure.

.. testcode:: sbm-example
   :hide:

   import os
   try:
      os.chdir("demos/inference")
   except FileNotFoundError:
       pass

   g = gt.load_graph("blockmodel-example.gt.gz")
   gt.graph_draw(g, pos=g.vp.pos, vertex_size=10, vertex_fill_color=g.vp.bo,
                 vertex_color="#333333",
                 edge_gradient=g.new_ep("vector<double>", val=[0]),
                 output="sbm-example.svg")

   ers = g.gp.w

   from pylab import *
   figure()
   matshow(log(ers))
   xlabel("Group $r$")
   ylabel("Group $s$")
   gca().xaxis.set_label_position("top") 
   savefig("sbm-example-ers.svg")

.. table::
    :class: figure

    +----------------------------------+------------------------------+
    |.. figure:: sbm-example-ers.svg   |.. figure:: sbm-example.svg   |
    |   :width: 300px                  |   :width: 300px              |
    |   :align: center                 |   :align: center             |
    |                                  |                              |
    |   Matrix of edge counts          |   Generated network.         |
    |   :math:`\boldsymbol e` between  |                              |
    |   groups.                        |                              |
    +----------------------------------+------------------------------+

.. note::

   We emphasize that no constraints are imposed on what `kind` of
   modular structure is allowed, as the matrix of edge counts :math:`e`
   is unconstrained. Hence, we can detect the putatively typical pattern
   of `"community structure"
   <https://en.wikipedia.org/wiki/Community_structure>`_, i.e. when
   nodes are connected mostly to other nodes of the same group, if it
   happens to be the most likely network description, but we can also
   detect a large multiplicity of other patterns, such as `bipartiteness
   <https://en.wikipedia.org/wiki/Bipartite_graph>`_, core-periphery,
   and many others, all under the same inference framework.


Although quite general, the traditional model assumes that the edges are
placed randomly inside each group, and because of this the nodes that
belong to the same group tend to have very similar degrees. As it turns
out, this is often a poor model for many networks, which possess highly
heterogeneous degree distributions. A better model for such networks is
called the `degree-corrected` stochastic block model
[karrer-stochastic-2011]_, and it is defined just like the traditional
model, with the addition of the degree sequence :math:`\boldsymbol k =
\{k_i\}` of the graph as an additional set of parameters (assuming again
a microcanonical formulation [peixoto-nonparametric-2017]_).


The nested stochastic block model
+++++++++++++++++++++++++++++++++

The regular SBM has a drawback when applied to large networks. Namely,
it cannot be used to find relatively small groups, as the maximum number
of groups that can be found scales as
:math:`B_{\text{max}}=O(\sqrt{N})`, where :math:`N` is the number of
nodes in the network, if Bayesian inference is performed
[peixoto-parsimonious-2013]_. In order to circumvent this, we need to
replace the noninformative priors used by a hierarchy of priors and
hyperpriors, which amounts to a `nested SBM`, where the groups
themselves are clustered into groups, and the matrix :math:`e` of edge
counts are generated from another SBM, and so on recursively
[peixoto-hierarchical-2014]_, as illustrated below.

.. figure:: nested-diagram.*
   :width: 400px
   :align: center

   Example of a nested SBM with three levels.

With this model, the maximum number of groups that can be inferred
scales as :math:`B_{\text{max}}=O(N/\log(N))`. In addition to being able
to find small groups in large networks, this model also provides a
multilevel hierarchical description of the network. With such a
description, we can uncover structural patterns at multiple scales,
representing different levels of coarse-graining.

Inferring the best partition
----------------------------

The simplest and most efficient approach is to find the best
partition of the network by maximizing Eq. :eq:`model-posterior`
according to some version of the model. This is obtained via the
functions :func:`~graph_tool.inference.minimize_blockmodel_dl` or
:func:`~graph_tool.inference.minimize_nested_blockmodel_dl`, which
employs an agglomerative multilevel `Markov chain Monte Carlo (MCMC)
<https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo>`_ algorithm
[peixoto-efficient-2014]_.

We focus first on the non-nested model, and we illustrate its use with a
network of American football teams, which we load from the
:mod:`~graph_tool.collection` module:

.. testsetup:: football

   import os
   try:
      os.chdir("demos/inference")
   except FileNotFoundError:
       pass
   gt.seed_rng(7)

.. testcode:: football

   g = gt.collection.data["football"]
   print(g)

which yields

.. testoutput:: football

   <Graph object, undirected, with 115 vertices and 613 edges at 0x...>

we then fit the degree-corrected model by calling

.. testcode:: football

   state = gt.minimize_blockmodel_dl(g)

This returns a :class:`~graph_tool.inference.BlockState` object that
includes the inference results.

.. note::

   The inference algorithm used is stochastic by nature, and may return
   a different answer each time it is run. This may be due to the fact
   that there are alternative partitions with similar probabilities, or
   that the optimum is difficult to find. Note that the inference
   problem here is, in general, `NP-Hard
   <https://en.wikipedia.org/wiki/NP-hardness>`_, hence there is no
   efficient algorithm that is guaranteed to always find the best
   answer.

   Because of this, typically one would call the algorithm many times,
   and select the partition with the largest posterior probability of
   Eq. :eq:`model-posterior`, or equivalently, the minimum description
   length of Eq. :eq:`model-dl`. The description length of a fit can be
   obtained with the :meth:`~graph_tool.inference.BlockState.entropy`
   method. See also Sec. :ref:`sec_model_selection` below.


We may perform a drawing of the partition obtained via the
:mod:`~graph_tool.inference.BlockState.draw` method, that functions as a
convenience wrapper to the :func:`~graph_tool.draw.graph_draw` function

.. testcode:: football

   state.draw(pos=g.vp.pos, output="football-sbm-fit.svg")

which yields the following image.

.. figure:: football-sbm-fit.*
   :align: center
   :width: 400px

   Stochastic block model inference of a network of American college
   football teams. The colors correspond to inferred group membership of
   the nodes.

We can obtain the group memberships as a
:class:`~graph_tool.PropertyMap` on the vertices via the
:mod:`~graph_tool.inference.BlockState.get_blocks` method:

.. testcode:: football

   b = state.get_blocks()
   r = b[10]   # group membership of vertex 10
   print(r)

which yields:

.. testoutput:: football

   3

We may also access the matrix of edge counts between groups via
:mod:`~graph_tool.inference.BlockState.get_matrix`

.. testcode:: football

   e = state.get_matrix()

   matshow(e.todense())
   savefig("football-edge-counts.svg")

.. figure:: football-edge-counts.*
   :align: center

   Matrix of edge counts between groups.

We may obtain the same matrix of edge counts as a graph, which has
internal edge and vertex property maps with the edge and vertex counts,
respectively:

.. testcode:: football

   bg = state.get_bg()
   ers = state.mrs    # edge counts
   nr = state.wr      # node counts

.. _sec_model_selection:

Hierarchical partitions
+++++++++++++++++++++++

The inference of the nested family of SBMs is done in a similar manner,
but we must use instead the
:func:`~graph_tool.inference.minimize_nested_blockmodel_dl` function. We
illustrate its use with the neural network of the `C. elegans
<https://en.wikipedia.org/wiki/Caenorhabditis_elegans>`_ worm:

.. testsetup:: celegans

   gt.seed_rng(43)

.. testcode:: celegans

   g = gt.collection.data["celegansneural"]
   print(g)

which has 297 vertices and 2359 edges.

.. testoutput:: celegans

   <Graph object, directed, with 297 vertices and 2359 edges at 0x...>

A hierarchical fit of the degree-corrected model is performed as follows.

.. testcode:: celegans

   state = gt.minimize_nested_blockmodel_dl(g)

The object returned is an instance of a
:class:`~graph_tool.inference.NestedBlockState` class, which
encapsulates the results. We can again draw the resulting hierarchical
clustering using the
:meth:`~graph_tool.inference.NestedBlockState.draw` method:

.. testcode:: celegans

   state.draw(output="celegans-hsbm-fit.svg")

.. figure:: celegans-hsbm-fit.*
   :align: center

   Most likely hierarchical partition of the neural network of
   the C. elegans worm according to the nested degree-corrected SBM.

.. note::

   If the ``output`` parameter to
   :meth:`~graph_tool.inference.NestedBlockState.draw` is omitted, an
   interactive visualization is performed, where the user can re-order
   the hierarchy nodes using the mouse and pressing the ``r`` key.

A summary of the inferred hierarchy can be obtained with the
:meth:`~graph_tool.inference.NestedBlockState.print_summary` method,
which shows the number of nodes and groups in all levels:

.. testcode:: celegans

   state.print_summary()

.. testoutput:: celegans

   l: 0, N: 297, B: 14
   l: 1, N: 14, B: 5
   l: 2, N: 5, B: 2
   l: 3, N: 2, B: 1

The hierarchical levels themselves are represented by individual
:meth:`~graph_tool.inference.BlockState` instances obtained via the
:meth:`~graph_tool.inference.NestedBlockState.get_levels()` method:

.. testcode:: celegans

   levels = state.get_levels()
   for s in levels:
       print(s)

.. testoutput:: celegans

   <BlockState object with 14 blocks (14 nonempty), degree-corrected, for graph <Graph object, directed, with 297 vertices and 2359 edges at 0x...>, at 0x...>
   <BlockState object with 5 blocks (5 nonempty), for graph <Graph object, directed, with 14 vertices and 129 edges at 0x...>, at 0x...>
   <BlockState object with 2 blocks (2 nonempty), for graph <Graph object, directed, with 5 vertices and 22 edges at 0x...>, at 0x...>
   <BlockState object with 1 blocks (1 nonempty), for graph <Graph object, directed, with 2 vertices and 4 edges at 0x...>, at 0x...>

This means that we can inspect the hierarchical partition just as before:

.. testcode:: celegans

   r = levels[0].get_blocks()[46]    # group membership of node 46 in level 0
   print(r)
   r = levels[0].get_blocks()[r]     # group membership of node 46 in level 1
   print(r)
   r = levels[0].get_blocks()[r]     # group membership of node 46 in level 2
   print(r)

.. testoutput:: celegans

   2
   1
   0

.. _model_selection:

Model selection
+++++++++++++++

As mentioned above, one can select the best model according to the
choice that yields the smallest description length. For instance, in
case of the `C. elegans` network we have

.. testsetup:: model-selection

   gt.seed_rng(43)

.. testcode:: model-selection

   g = gt.collection.data["celegansneural"]

   state_ndc = gt.minimize_nested_blockmodel_dl(g, deg_corr=False)
   state_dc  = gt.minimize_nested_blockmodel_dl(g, deg_corr=True)

   print("Non-degree-corrected DL:\t", state_ndc.entropy())
   print("Degree-corrected DL:\t", state_dc.entropy())

.. testoutput:: model-selection
   :options: +NORMALIZE_WHITESPACE

   Non-degree-corrected DL:	 8511.005312...
   Degree-corrected DL:	 8225.167736...
   
Since it yields the smallest description length, the degree-corrected
fit should be preferred. The statistical significance of the choice can
be accessed by inspecting the posterior odds ratio
[peixoto-nonparametric-2017]_

.. math::

   \Lambda &= \frac{P(\boldsymbol b, \mathcal{H}_\text{NDC} | \boldsymbol G)}{P(\boldsymbol b, \mathcal{H}_\text{DC} | \boldsymbol G)} \\
           &= \frac{P(\boldsymbol G, \boldsymbol b | \mathcal{H}_\text{NDC})}{P(\boldsymbol G, \boldsymbol b | \mathcal{H}_\text{DC})}\times\frac{P(\mathcal{H}_\text{NDC})}{P(\mathcal{H}_\text{DC})} \\
           &= \exp(-\Delta\Sigma)

where :math:`\mathcal{H}_\text{NDC}` and :math:`\mathcal{H}_\text{DC}`
correspond to the non-degree-corrected and degree-corrected model
hypotheses (assumed to be equally likely `a priori`), respectively, and
:math:`\Delta\Sigma` is the difference of the description length of both
fits. In our particular case, we have

.. testcode:: model-selection

   print(u"ln \u039b: ", state_dc.entropy() - state_ndc.entropy())

.. testoutput:: model-selection
   :options: +NORMALIZE_WHITESPACE

   ln Λ:  -285.837575...

The precise threshold that should be used to decide when to `reject a
hypothesis <https://en.wikipedia.org/wiki/Hypothesis_testing>`_ is
subjective and context-dependent, but the value above implies that the
particular degree-corrected fit is around :math:`\mathrm{e}^{327} \approx 10^{142}`
times more likely than the non-degree corrected one, and hence it can be
safely concluded that it provides a substantially better fit.

Although it is often true that the degree-corrected model provides a
better fit for many empirical networks, there are also exceptions. For
example, for the American football network above, we have:

.. testcode:: model-selection

   g = gt.collection.data["football"]

   state_ndc = gt.minimize_nested_blockmodel_dl(g, deg_corr=False)
   state_dc  = gt.minimize_nested_blockmodel_dl(g, deg_corr=True)

   print("Non-degree-corrected DL:\t", state_ndc.entropy())
   print("Degree-corrected DL:\t", state_dc.entropy())
   print(u"ln \u039b:\t\t\t", state_ndc.entropy() - state_dc.entropy())

.. testoutput:: model-selection
   :options: +NORMALIZE_WHITESPACE

   Non-degree-corrected DL:      1733.525685...
   Degree-corrected DL:          1791.750418...
   ln Λ:                         -58.224733...

Hence, with a posterior odds ratio of :math:`\Lambda \approx \mathrm{e}^{-58} \approx
10^{-26}` in favor of the non-degree-corrected model, it seems like the
degree-corrected variant is an unnecessarily complex description for
this network.

.. _sampling:

Sampling from the posterior distribution
----------------------------------------

When analyzing empirical networks, one should be open to the possibility
that there will be more than one fit of the SBM with similar posterior
probabilities. In such situations, one should instead `sample`
partitions from the posterior distribution, instead of simply finding
its maximum. One can then compute quantities that are averaged over the
different model fits, weighted according to their posterior
probabilities.

Full support for model averaging is implemented in ``graph-tool`` via an
efficient `Markov chain Monte Carlo (MCMC)
<https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo>`_ algorithm
[peixoto-efficient-2014]_. It works by attempting to move nodes into
different groups with specific probabilities, and `accepting or
rejecting
<https://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm>`_
such moves so that, after a sufficiently long time, the partitions will
be observed with the desired posterior probability. The algorithm is
designed so that its run-time (i.e. each sweep of the MCMC) is linear on
the number of edges in the network, and independent on the number of
groups being used in the model, and hence is suitable for use on very
large networks.

In order to perform such moves, one needs again to operate with
:class:`~graph_tool.inference.BlockState` or
:class:`~graph_tool.inference.NestedBlockState` instances, and calling
their :meth:`~graph_tool.inference.BlockState.mcmc_sweep` methods. For
example, the following will perform 1000 sweeps of the algorithm with
the network of characters in the novel Les Misérables, starting from a
random partition into 20 groups

.. testcode:: model-averaging

   g = gt.collection.data["lesmis"]

   state = gt.BlockState(g, B=20)   # This automatically initializes the state
                                    # with a random partition into B=20
                                    # nonempty groups; The user could
                                    # also pass an arbitrary initial
                                    # partition using the 'b' parameter.

   # Now we run 1,000 sweeps of the MCMC. Note that the number of groups
   # is allowed to change, so it will eventually move from the initial
   # value of B=20 to whatever is most appropriate for the data.

   dS, nmoves = state.mcmc_sweep(niter=1000)

   print("Change in description length:", dS)
   print("Number of accepted vertex moves:", nmoves)

.. testoutput:: model-averaging

   Change in description length: -345.376523...
   Number of accepted vertex moves: 34222

.. note::

   Starting from a random partition is rarely the best option, since it
   may take a long time for it to equilibrate. It was done above simply
   as an illustration on how to initialize
   :class:`~graph_tool.inference.BlockState` by hand. Instead, a much
   better option in practice is to start from an approximation to the
   "ground state" obtained with
   :func:`~graph_tool.inference.minimize_blockmodel_dl`, e.g.

    .. testcode:: model-averaging

       state = gt.minimize_blockmodel_dl(g)
       state = state.copy(B=g.num_vertices())
       dS, nmoves = state.mcmc_sweep(niter=1000)

       print("Change in description length:", dS)
       print("Number of accepted vertex moves:", nmoves)

    .. testoutput:: model-averaging

       Change in description length: 16.124022...
       Number of accepted vertex moves: 41393

Although the above is sufficient to implement model averaging, there is a
convenience function called
:func:`~graph_tool.inference.mcmc_equilibrate` that is intend to
simplify the detection of equilibration, by keeping track of the maximum
and minimum values of description length encountered and how many sweeps
have been made without a "record breaking" event. For example,

.. testcode:: model-averaging

   # We will accept equilibration if 10 sweeps are completed without a
   # record breaking event, 2 consecutive times.

   gt.mcmc_equilibrate(state, wait=10, nbreaks=2, mcmc_args=dict(niter=10), verbose=True)

will output:

.. testoutput:: model-averaging
    :options: +NORMALIZE_WHITESPACE

    niter:     1  count:    0  breaks:  0  min_S: 713.72081  max_S: 720.04438  S: 713.72081  ΔS:     -6.32357  moves:   418 
    niter:     2  count:    0  breaks:  0  min_S: 713.72081  max_S: 728.31214  S: 728.31214  ΔS:      14.5913  moves:   384 
    niter:     3  count:    0  breaks:  0  min_S: 713.70119  max_S: 728.31214  S: 713.70119  ΔS:     -14.6110  moves:   443 
    niter:     4  count:    1  breaks:  0  min_S: 713.70119  max_S: 728.31214  S: 722.48803  ΔS:      8.78684  moves:   391 
    niter:     5  count:    2  breaks:  0  min_S: 713.70119  max_S: 728.31214  S: 727.05935  ΔS:      4.57131  moves:   378 
    niter:     6  count:    3  breaks:  0  min_S: 713.70119  max_S: 728.31214  S: 727.29821  ΔS:     0.238862  moves:   344 
    niter:     7  count:    0  breaks:  0  min_S: 713.70119  max_S: 743.00358  S: 743.00358  ΔS:      15.7054  moves:   376 
    niter:     8  count:    0  breaks:  0  min_S: 711.80965  max_S: 743.00358  S: 711.80965  ΔS:     -31.1939  moves:   382 
    niter:     9  count:    1  breaks:  0  min_S: 711.80965  max_S: 743.00358  S: 712.92615  ΔS:      1.11651  moves:   343 
    niter:    10  count:    2  breaks:  0  min_S: 711.80965  max_S: 743.00358  S: 721.94043  ΔS:      9.01428  moves:   388 
    niter:    11  count:    3  breaks:  0  min_S: 711.80965  max_S: 743.00358  S: 719.13006  ΔS:     -2.81037  moves:   362 
    niter:    12  count:    4  breaks:  0  min_S: 711.80965  max_S: 743.00358  S: 729.78095  ΔS:      10.6509  moves:   383 
    niter:    13  count:    5  breaks:  0  min_S: 711.80965  max_S: 743.00358  S: 720.04992  ΔS:     -9.73104  moves:   376 
    niter:    14  count:    6  breaks:  0  min_S: 711.80965  max_S: 743.00358  S: 732.90657  ΔS:      12.8567  moves:   387 
    niter:    15  count:    7  breaks:  0  min_S: 711.80965  max_S: 743.00358  S: 717.42580  ΔS:     -15.4808  moves:   380 
    niter:    16  count:    8  breaks:  0  min_S: 711.80965  max_S: 743.00358  S: 716.75399  ΔS:    -0.671812  moves:   359 
    niter:    17  count:    0  breaks:  0  min_S: 711.80965  max_S: 745.15972  S: 745.15972  ΔS:      28.4057  moves:   350 
    niter:    18  count:    1  breaks:  0  min_S: 711.80965  max_S: 745.15972  S: 728.99832  ΔS:     -16.1614  moves:   389 
    niter:    19  count:    2  breaks:  0  min_S: 711.80965  max_S: 745.15972  S: 720.84596  ΔS:     -8.15237  moves:   348 
    niter:    20  count:    0  breaks:  0  min_S: 709.75049  max_S: 745.15972  S: 709.75049  ΔS:     -11.0955  moves:   392 
    niter:    21  count:    1  breaks:  0  min_S: 709.75049  max_S: 745.15972  S: 721.10373  ΔS:      11.3532  moves:   341 
    niter:    22  count:    2  breaks:  0  min_S: 709.75049  max_S: 745.15972  S: 718.50836  ΔS:     -2.59537  moves:   354 
    niter:    23  count:    3  breaks:  0  min_S: 709.75049  max_S: 745.15972  S: 714.36017  ΔS:     -4.14819  moves:   375 
    niter:    24  count:    0  breaks:  0  min_S: 707.10762  max_S: 745.15972  S: 707.10762  ΔS:     -7.25255  moves:   367 
    niter:    25  count:    1  breaks:  0  min_S: 707.10762  max_S: 745.15972  S: 708.42197  ΔS:      1.31435  moves:   372 
    niter:    26  count:    0  breaks:  0  min_S: 704.56635  max_S: 745.15972  S: 704.56635  ΔS:     -3.85562  moves:   346 
    niter:    27  count:    1  breaks:  0  min_S: 704.56635  max_S: 745.15972  S: 725.76740  ΔS:      21.2011  moves:   338 
    niter:    28  count:    2  breaks:  0  min_S: 704.56635  max_S: 745.15972  S: 708.78787  ΔS:     -16.9795  moves:   378 
    niter:    29  count:    3  breaks:  0  min_S: 704.56635  max_S: 745.15972  S: 722.03356  ΔS:      13.2457  moves:   382 
    niter:    30  count:    0  breaks:  0  min_S: 704.10199  max_S: 745.15972  S: 704.10199  ΔS:     -17.9316  moves:   375 
    niter:    31  count:    1  breaks:  0  min_S: 704.10199  max_S: 745.15972  S: 713.64366  ΔS:      9.54166  moves:   382 
    niter:    32  count:    2  breaks:  0  min_S: 704.10199  max_S: 745.15972  S: 727.65050  ΔS:      14.0068  moves:   383 
    niter:    33  count:    3  breaks:  0  min_S: 704.10199  max_S: 745.15972  S: 720.51443  ΔS:     -7.13607  moves:   379 
    niter:    34  count:    4  breaks:  0  min_S: 704.10199  max_S: 745.15972  S: 726.77412  ΔS:      6.25969  moves:   366 
    niter:    35  count:    5  breaks:  0  min_S: 704.10199  max_S: 745.15972  S: 722.96778  ΔS:     -3.80634  moves:   382 
    niter:    36  count:    6  breaks:  0  min_S: 704.10199  max_S: 745.15972  S: 717.65450  ΔS:     -5.31328  moves:   394 
    niter:    37  count:    7  breaks:  0  min_S: 704.10199  max_S: 745.15972  S: 734.02750  ΔS:      16.3730  moves:   377 
    niter:    38  count:    8  breaks:  0  min_S: 704.10199  max_S: 745.15972  S: 727.36795  ΔS:     -6.65954  moves:   393 
    niter:    39  count:    9  breaks:  0  min_S: 704.10199  max_S: 745.15972  S: 719.39773  ΔS:     -7.97022  moves:   382 
    niter:    40  count:    0  breaks:  1  min_S: 718.06061  max_S: 718.06061  S: 718.06061  ΔS:     -1.33712  moves:   411 
    niter:    41  count:    0  breaks:  1  min_S: 708.36787  max_S: 718.06061  S: 708.36787  ΔS:     -9.69274  moves:   398 
    niter:    42  count:    0  breaks:  1  min_S: 708.36787  max_S: 729.98460  S: 729.98460  ΔS:      21.6167  moves:   406 
    niter:    43  count:    1  breaks:  1  min_S: 708.36787  max_S: 729.98460  S: 719.27340  ΔS:     -10.7112  moves:   383 
    niter:    44  count:    2  breaks:  1  min_S: 708.36787  max_S: 729.98460  S: 709.89100  ΔS:     -9.38239  moves:   409 
    niter:    45  count:    3  breaks:  1  min_S: 708.36787  max_S: 729.98460  S: 721.29921  ΔS:      11.4082  moves:   383 
    niter:    46  count:    0  breaks:  1  min_S: 706.67224  max_S: 729.98460  S: 706.67224  ΔS:     -14.6270  moves:   405 
    niter:    47  count:    1  breaks:  1  min_S: 706.67224  max_S: 729.98460  S: 711.87311  ΔS:      5.20087  moves:   373 
    niter:    48  count:    2  breaks:  1  min_S: 706.67224  max_S: 729.98460  S: 708.20851  ΔS:     -3.66460  moves:   367 
    niter:    49  count:    3  breaks:  1  min_S: 706.67224  max_S: 729.98460  S: 712.26954  ΔS:      4.06103  moves:   368 
    niter:    50  count:    4  breaks:  1  min_S: 706.67224  max_S: 729.98460  S: 717.69181  ΔS:      5.42227  moves:   396 
    niter:    51  count:    5  breaks:  1  min_S: 706.67224  max_S: 729.98460  S: 716.64174  ΔS:     -1.05008  moves:   395 
    niter:    52  count:    0  breaks:  1  min_S: 706.67224  max_S: 731.96439  S: 731.96439  ΔS:      15.3226  moves:   387 
    niter:    53  count:    1  breaks:  1  min_S: 706.67224  max_S: 731.96439  S: 722.51613  ΔS:     -9.44825  moves:   411 
    niter:    54  count:    2  breaks:  1  min_S: 706.67224  max_S: 731.96439  S: 719.18164  ΔS:     -3.33449  moves:   414 
    niter:    55  count:    3  breaks:  1  min_S: 706.67224  max_S: 731.96439  S: 712.43942  ΔS:     -6.74222  moves:   395 
    niter:    56  count:    4  breaks:  1  min_S: 706.67224  max_S: 731.96439  S: 720.71508  ΔS:      8.27565  moves:   395 
    niter:    57  count:    5  breaks:  1  min_S: 706.67224  max_S: 731.96439  S: 718.75450  ΔS:     -1.96058  moves:   379 
    niter:    58  count:    6  breaks:  1  min_S: 706.67224  max_S: 731.96439  S: 710.43596  ΔS:     -8.31854  moves:   428 
    niter:    59  count:    7  breaks:  1  min_S: 706.67224  max_S: 731.96439  S: 723.89819  ΔS:      13.4622  moves:   408 
    niter:    60  count:    8  breaks:  1  min_S: 706.67224  max_S: 731.96439  S: 718.87456  ΔS:     -5.02363  moves:   435 
    niter:    61  count:    9  breaks:  1  min_S: 706.67224  max_S: 731.96439  S: 721.20227  ΔS:      2.32772  moves:   399 
    niter:    62  count:   10  breaks:  2  min_S: 706.67224  max_S: 731.96439  S: 726.81344  ΔS:      5.61116  moves:   383 

Note that the value of ``wait`` above was made purposefully low so that
the output would not be overly long. The most appropriate value requires
experimentation, but a typically good value is ``wait=1000``.

The function :func:`~graph_tool.inference.mcmc_equilibrate` accepts a
``callback`` argument that takes an optional function to be invoked
after each call to
:meth:`~graph_tool.inference.BlockState.mcmc_sweep`. This function
should accept a single parameter which will contain the actual
:class:`~graph_tool.inference.BlockState` instance. We will use this in
the example below to collect the posterior vertex marginals (via
:class:`~graph_tool.inference.BlockState.collect_vertex_marginals`),
i.e. the posterior probability that a node belongs to a given group:

.. testcode:: model-averaging

   # We will first equilibrate the Markov chain
   gt.mcmc_equilibrate(state, wait=1000, mcmc_args=dict(niter=10))

   pv = None 

   def collect_marginals(s):
      global pv
      pv = s.collect_vertex_marginals(pv)

   # Now we collect the marginals for exactly 100,000 sweeps, at
   # intervals of 10 sweeps:
   gt.mcmc_equilibrate(state, force_niter=10000, mcmc_args=dict(niter=10),
                       callback=collect_marginals)

   # Now the node marginals are stored in property map pv. We can
   # visualize them as pie charts on the nodes:
   state.draw(pos=g.vp.pos, vertex_shape="pie", vertex_pie_fractions=pv,
              edge_gradient=None, output="lesmis-sbm-marginals.svg")

.. figure:: lesmis-sbm-marginals.*
   :align: center
   :width: 450px

   Marginal probabilities of group memberships of the network of
   characters in the novel Les Misérables, according to the
   degree-corrected SBM. The `pie fractions
   <https://en.wikipedia.org/wiki/Pie_chart>`_ on the nodes correspond
   to the probability of being in group associated with the respective
   color.

We can also obtain a marginal probability on the number of groups
itself, as follows.

.. testcode:: model-averaging

   h = np.zeros(g.num_vertices() + 1)

   def collect_num_groups(s):
       B = s.get_nonempty_B()
       h[B] += 1

   # Now we collect the marginals for exactly 100,000 sweeps, at
   # intervals of 10 sweeps:
   gt.mcmc_equilibrate(state, force_niter=10000, mcmc_args=dict(niter=10),
                       callback=collect_num_groups)

.. testcode:: model-averaging
   :hide:

   figure()
   Bs = np.arange(len(h))
   idx = h > 0
   bar(Bs[idx], h[idx] / h.sum(), width=1, color="#ccb974")
   gca().set_xticks([6,7,8,9])
   xlabel("$B$")
   ylabel(r"$P(B|\boldsymbol G)$")
   savefig("lesmis-B-posterior.svg")

.. figure:: lesmis-B-posterior.*
   :align: center

   Marginal posterior probability of the number of nonempty groups for
   the network of characters in the novel Les Misérables, according to
   the degree-corrected SBM.


Hierarchical partitions
+++++++++++++++++++++++

We can also perform model averaging using the nested SBM, which will
give us a distribution over hierarchies. The whole procedure is fairly
analogous, but now we make use of
:class:`~graph_tool.inference.NestedBlockState` instances.

.. note::

    When using :class:`~graph_tool.inference.NestedBlockState` instances
    to perform model averaging, they need to be constructed with the
    option ``sampling=True``.

Here we perform the sampling of hierarchical partitions using the same
network as above.

.. testcode:: nested-model-averaging

   g = gt.collection.data["lesmis"]

   state = gt.minimize_nested_blockmodel_dl(g) # Initialize he Markov
                                               # chain from the "ground
                                               # state"

   # Before doing model averaging, the need to create a NestedBlockState
   # by passing sampling = True.

   # We also want to increase the maximum hierarchy depth to L = 10

   # We can do both of the above by copying.

   bs = state.get_bs()                     # Get hierarchical partition.
   bs += [np.zeros(1)] * (10 - len(bs))    # Augment it to L = 10 with
                                           # single-group levels.

   state = state.copy(bs=bs, sampling=True)

   # Now we run 1000 sweeps of the MCMC

   dS, nmoves = state.mcmc_sweep(niter=1000)

   print("Change in description length:", dS)
   print("Number of accepted vertex moves:", nmoves)

.. testoutput:: nested-model-averaging

   Change in description length: 23.368680...
   Number of accepted vertex moves: 46167

Similarly to the the non-nested case, we can use
:func:`~graph_tool.inference.mcmc_equilibrate` to do most of the boring
work, and we can now obtain vertex marginals on all hierarchical levels:


.. testcode:: nested-model-averaging

   # We will first equilibrate the Markov chain
   gt.mcmc_equilibrate(state, wait=1000, mcmc_args=dict(niter=10))

   pv = [None] * len(state.get_levels())

   def collect_marginals(s):
      global pv
      pv = [sl.collect_vertex_marginals(pv[l]) for l, sl in enumerate(s.get_levels())]

   # Now we collect the marginals for exactly 100,000 sweeps
   gt.mcmc_equilibrate(state, force_niter=10000, mcmc_args=dict(niter=10),
                       callback=collect_marginals)

   # Now the node marginals for all levels are stored in property map
   # list pv. We can visualize the first level as pie charts on the nodes:
   state_0 = state.get_levels()[0]
   state_0.draw(pos=g.vp.pos, vertex_shape="pie", vertex_pie_fractions=pv[0],
                edge_gradient=None, output="lesmis-nested-sbm-marginals.svg")

.. figure:: lesmis-nested-sbm-marginals.*
   :align: center
   :width: 450px

   Marginal probabilities of group memberships of the network of
   characters in the novel Les Misérables, according to the nested
   degree-corrected SBM. The pie fractions on the nodes correspond to
   the probability of being in group associated with the respective
   color.

We can also obtain a marginal probability of the number of groups
itself, as follows.

.. testcode:: nested-model-averaging

   h = [np.zeros(g.num_vertices() + 1) for s in state.get_levels()]

   def collect_num_groups(s):
       for l, sl in enumerate(s.get_levels()):
          B = sl.get_nonempty_B()
          h[l][B] += 1

   # Now we collect the marginal distribution for exactly 100,000 sweeps
   gt.mcmc_equilibrate(state, force_niter=10000, mcmc_args=dict(niter=10),
                       callback=collect_num_groups)

.. testcode:: nested-model-averaging
   :hide:

   figure()
   f, ax = plt.subplots(1, 5, figsize=(10, 3))
   for i, h_ in enumerate(h[:5]):
       Bs = np.arange(len(h_))
       idx = h_ > 0
       ax[i].bar(Bs[idx], h_[idx] / h_.sum(), width=1, color="#ccb974")
       ax[i].set_xticks(Bs[idx])
       ax[i].set_xlabel("$B_{%d}$" % i)
       ax[i].set_ylabel(r"$P(B_{%d}|\boldsymbol G)$" % i)
       locator = MaxNLocator(prune='both', nbins=5)
       ax[i].yaxis.set_major_locator(locator)
   tight_layout()
   savefig("lesmis-nested-B-posterior.svg")

.. figure:: lesmis-nested-B-posterior.*
   :align: center

   Marginal posterior probability of the number of nonempty groups
   :math:`B_l` at each hierarchy level :math:`l` for the network of
   characters in the novel Les Misérables, according to the nested
   degree-corrected SBM.

Below we obtain some hierarchical partitions sampled from the posterior
distribution.

.. testcode:: nested-model-averaging

   for i in range(10):
       state.mcmc_sweep(niter=1000)
       state.draw(output="lesmis-partition-sample-%i.svg" % i, empty_branches=False)

.. image:: lesmis-partition-sample-0.svg
   :width: 200px
.. image:: lesmis-partition-sample-1.svg
   :width: 200px
.. image:: lesmis-partition-sample-2.svg
   :width: 200px
.. image:: lesmis-partition-sample-3.svg
   :width: 200px
.. image:: lesmis-partition-sample-4.svg
   :width: 200px
.. image:: lesmis-partition-sample-5.svg
   :width: 200px
.. image:: lesmis-partition-sample-6.svg
   :width: 200px
.. image:: lesmis-partition-sample-7.svg
   :width: 200px
.. image:: lesmis-partition-sample-8.svg
   :width: 200px
.. image:: lesmis-partition-sample-9.svg
   :width: 200px

Model class selection
+++++++++++++++++++++

When averaging over partitions, we may be interested in evaluating which
**model class** provides a better fit of the data, considering all
possible parameter choices. This is done by evaluating the model
evidence summed over all possible partitions [peixoto-nonparametric-2017]_:

.. math::

   P(\boldsymbol G) = \sum_{\boldsymbol\theta,\boldsymbol b}P(\boldsymbol G,\boldsymbol\theta, \boldsymbol b) =  \sum_{\boldsymbol b}P(\boldsymbol G,\boldsymbol b).

This quantity is analogous to a `partition function
<https://en.wikipedia.org/wiki/Partition_function_(statistical_mechanics)>`_
in statistical physics, which we can write more conveniently as a
negative `free energy
<https://en.wikipedia.org/wiki/Thermodynamic_free_energy>`_ by taking
its logarithm

.. math::
   :label: free-energy

   \ln P(\boldsymbol G) = \underbrace{\sum_{\boldsymbol b}q(\boldsymbol b)\ln P(\boldsymbol G,\boldsymbol b)}_{-\left<\Sigma\right>}\;
              \underbrace{- \sum_{\boldsymbol b}q(\boldsymbol b)\ln q(\boldsymbol b)}_{\mathcal{S}}

where

.. math::

   q(\boldsymbol b) = \frac{P(\boldsymbol G,\boldsymbol b)}{\sum_{\boldsymbol b'}P(\boldsymbol G,\boldsymbol b')}

is the posterior probability of partition :math:`\boldsymbol b`. The
first term of Eq. :eq:`free-energy` (the "negative energy") is minus the
average of description length :math:`\left<\Sigma\right>`, weighted
according to the posterior distribution. The second term
:math:`\mathcal{S}` is the `entropy
<https://en.wikipedia.org/wiki/Entropy_(information_theory)>`_ of the
posterior distribution, and measures, in a sense, the "quality of fit"
of the model: If the posterior is very "peaked", i.e. dominated by a
single partition with a very large probability, the entropy will tend to
zero. However, if there are many partitions with similar probabilities
--- meaning that there is no single partition that describes the network
uniquely well --- it will take a large value instead.

Since the MCMC algorithm samples partitions from the distribution
:math:`q(\boldsymbol b)`, it can be used to compute
:math:`\left<\Sigma\right>` easily, simply by averaging the description
length values encountered by sampling from the posterior distribution
many times.

The computation of the posterior entropy :math:`\mathcal{S}`, however,
is significantly more difficult, since it involves measuring the precise
value of :math:`q(\boldsymbol b)`. A direct "brute force" computation of
:math:`\mathcal{S}` is implemented via
:meth:`~graph_tool.inference.BlockState.collect_partition_histogram` and
:func:`~graph_tool.inference.microstate_entropy`, however this is only
feasible for very small networks. For larger networks, we are forced to
perform approximations. The simplest is a "mean field" one, where we
assume the posterior factorizes as

.. math::

   q(\boldsymbol b) \approx \prod_i{q_i(b_i)}

where

.. math::

   q_i(r) = P(b_i = r | \boldsymbol G)

is the marginal group membership distribution of node :math:`i`. This
yields an entropy value given by

.. math::

   S \approx -\sum_i\sum_rq_i(r)\ln q_i(r).

This approximation should be seen as an upper bound, since any existing
correlation between the nodes (which are ignored here) will yield
smaller entropy values.

A more accurate assumption is called the `Bethe approximation`
[mezard-information-2009]_, and takes into account the correlation
between adjacent nodes in the network,

.. math::

   q(\boldsymbol b) \approx \prod_{i<j}q_{ij}(b_i,b_j)^{A_{ij}}\prod_iq_i(b_i)^{1-k_i}

where :math:`A_{ij}` is the `adjacency matrix
<https://en.wikipedia.org/wiki/Adjacency_matrix>`_, :math:`k_i` is the
degree of node :math:`i`, and

.. math::

   q_{ij}(r, s) = P(b_i = r, b_j = s|\boldsymbol G)

is the joint group membership distribution of nodes :math:`i` and
:math:`j` (a.k.a. the `edge marginals`). This yields an entropy value
given by

.. math::

   S \approx -\sum_{i<j}A_{ij}\sum_{rs}q_{ij}(r,s)\ln q_{ij}(r,s) - \sum_i(1-k_i)\sum_rq_i(r)\ln q_i(r).

Typically, this approximation yields smaller values than the mean field
one, and is generally considered to be superior. However, formally, it
depends on the graph being sufficiently locally "tree-like", and the
posterior being indeed strongly correlated with the adjacency matrix
itself --- two characteristics which do not hold in general. Although
the approximation often gives reasonable results even when these
conditions do not strictly hold, in some situations when they are
strongly violated this approach can yield meaningless values, such as a
negative entropy. Therefore, it is useful to compare both approaches
whenever possible.

With these approximations, it possible to estimate the full model
evidence efficiently, as we show below, using
:meth:`~graph_tool.inference.BlockState.collect_vertex_marginals`,
:meth:`~graph_tool.inference.BlockState.collect_edge_marginals`,
:meth:`~graph_tool.inference.mf_entropy` and
:meth:`~graph_tool.inference.bethe_entropy`.

.. testcode:: model-evidence

   g = gt.collection.data["lesmis"]

   for deg_corr in [True, False]:
       state = gt.minimize_blockmodel_dl(g, deg_corr=deg_corr)     # Initialize the Markov
                                                                   # chain from the "ground
                                                                   # state"
       state = state.copy(B=g.num_vertices())

       dls = []         # description length history
       vm = None        # vertex marginals
       em = None        # edge marginals

       def collect_marginals(s):
           global vm, em
           vm = s.collect_vertex_marginals(vm)
           em = s.collect_edge_marginals(em)
           dls.append(s.entropy())

       # Now we collect the marginal distributions for exactly 200,000 sweeps
       gt.mcmc_equilibrate(state, force_niter=20000, mcmc_args=dict(niter=10),
                           callback=collect_marginals)

       S_mf = gt.mf_entropy(g, vm)
       S_bethe = gt.bethe_entropy(g, em)[0]
       L = -mean(dls)

       print("Model evidence for deg_corr = %s:" % deg_corr,
             L + S_mf, "(mean field),", L + S_bethe, "(Bethe)")

.. testoutput:: model-evidence

   Model evidence for deg_corr = True: -588.9373... (mean field), -749.3004... (Bethe)
   Model evidence for deg_corr = False: -593.393... (mean field), -709.6448... (Bethe)

If we consider the more accurate approximation, the outcome shows a
preference for the non-degree-corrected model.

When using the nested model, the approach is entirely analogous. The
only difference now is that we have a hierarchical partition
:math:`\{\boldsymbol b_l\}` in the equations above, instead of simply
:math:`\boldsymbol b`. In order to make the approach tractable, we
assume the factorization

.. math::

   q(\{\boldsymbol b_l\}) \approx \prod_lq_l(\boldsymbol b_l)

where :math:`q_l(\boldsymbol b_l)` is the marginal posterior for the
partition at level :math:`l`. For :math:`q_0(\boldsymbol b_0)` we may
use again either the mean-field or Bethe approximations, however for
:math:`l>0` only the mean-field approximation is applicable, since the
adjacency matrix of the higher layers is not constant. We show below the
approach for the same network, using the nested model.


.. testcode:: model-evidence

   g = gt.collection.data["lesmis"]

   nL = 10

   for deg_corr in [True, False]:
       state = gt.minimize_nested_blockmodel_dl(g, deg_corr=deg_corr)     # Initialize the Markov
                                                                          # chain from the "ground
                                                                          # state"
       bs = state.get_bs()                     # Get hierarchical partition.
       bs += [np.zeros(1)] * (nL - len(bs))    # Augment it to L = 10 with
                                               # single-group levels.

       state = state.copy(bs=bs, sampling=True)

       dls = []                               # description length history
       vm = [None] * len(state.get_levels())  # vertex marginals
       em = None                              # edge marginals

       def collect_marginals(s):
           global vm, em
           levels = s.get_levels()
           vm = [sl.collect_vertex_marginals(vm[l]) for l, sl in enumerate(levels)]
           em = levels[0].collect_edge_marginals(em)
           dls.append(s.entropy())

       # Now we collect the marginal distributions for exactly 200,000 sweeps
       gt.mcmc_equilibrate(state, force_niter=20000, mcmc_args=dict(niter=10),
                           callback=collect_marginals)

       S_mf = [gt.mf_entropy(sl.g, vm[l]) for l, sl in enumerate(state.get_levels())]
       S_bethe = gt.bethe_entropy(g, em)[0]
       L = -mean(dls)

       print("Model evidence for deg_corr = %s:" % deg_corr,
             L + sum(S_mf), "(mean field),", L + S_bethe + sum(S_mf[1:]), "(Bethe)")


.. testoutput:: model-evidence

   Model evidence for deg_corr = True: -554.46079... (mean field), -699.6147... (Bethe)
   Model evidence for deg_corr = False: -548.6576... (mean field), -635.5347... (Bethe)

The results are similar: If we consider the most accurate approximation,
the non-degree-corrected model possesses the largest evidence. Note also
that we observe a better evidence for the nested models themselves, when
comparing to the evidences for the non-nested model --- which is not
quite surprising, since the non-nested model is a special case of the
nested one.

.. _weights:

Edge weights and covariates
---------------------------

Very often networks cannot be completely represented by simple graphs,
but instead have arbitrary "weights" :math:`x_{ij}` on the edges. Edge
weights can be continuous or discrete numbers, and either strictly
positive or positive or negative, depending on context. The SBM can be
extended to cover these cases by treating edge weights as covariates
that are sampled from some distribution conditioned on the node
partition [aicher-learning-2015]_ [peixoto-weighted-2017]_, i.e.

.. math::

   P(\boldsymbol x,\boldsymbol G|\boldsymbol b) =
   P(\boldsymbol x|\boldsymbol G,\boldsymbol b) P(\boldsymbol G|\boldsymbol b),

where :math:`P(\boldsymbol G|\boldsymbol b)` is the likelihood of the
unweighted SBM described previously, and :math:`P(\boldsymbol
x|\boldsymbol G,\boldsymbol b)` is the integrated likelihood of the edge
weights

.. math::

   P(\boldsymbol x|\boldsymbol G,\boldsymbol b) =
   \prod_{r\le s}\int P({\boldsymbol x}_{rs}|\gamma)P(\gamma)\,\mathrm{d}\gamma,

where :math:`P({\boldsymbol x}_{rs}|\gamma)` is some model for the weights
:math:`{\boldsymbol x}_{rs}` between groups :math:`(r,s)`, conditioned on
some parameter :math:`\gamma`, sampled from its prior
:math:`P(\gamma)`. A hierarchical version of the model can also be
implemented by replacing this prior by a nested sequence of priors and
hyperpriors, as described in [peixoto-weighted-2017]_. The posterior
partition distribution is then simply

.. math::

   P(\boldsymbol b | \boldsymbol G,\boldsymbol x) =
   \frac{P(\boldsymbol x|\boldsymbol G,\boldsymbol b) P(\boldsymbol G|\boldsymbol b)
         P(\boldsymbol b)}{P(\boldsymbol G,\boldsymbol x)},

which can be sampled from, or maximized, just like with the unweighted
case, but will use the information on the weights to guide the partitions.

A variety of weight models is supported, reflecting different kinds of
edge covariates:

.. csv-table::
   :header: "Name", "Domain", "Bounds", "Shape"
   :widths: 10, 5, 5, 5
   :delim: |
   :align: center

   ``"real-exponential"``   | Real    :math:`(\mathbb{R})` | :math:`[0,\infty]`       | `Exponential <https://en.wikipedia.org/wiki/Exponential_distribution>`_
   ``"real-normal"``        | Real    :math:`(\mathbb{R})` | :math:`[-\infty,\infty]` | `Normal <https://en.wikipedia.org/wiki/Normal_distribution>`_
   ``"discrete-geometric"`` | Natural :math:`(\mathbb{N})` | :math:`[0,\infty]`       | `Geometric <https://en.wikipedia.org/wiki/Geometric_distribution>`_
   ``"discrete-binomial"``  | Natural :math:`(\mathbb{N})` | :math:`[0,M]`            | `Binomial <https://en.wikipedia.org/wiki/Binomial_distribution>`_
   ``"discrete-poisson"``   | Natural :math:`(\mathbb{N})` | :math:`[0,\infty]`       | `Poisson <https://en.wikipedia.org/wiki/Poisson_distribution>`_

In fact, the actual model implements `microcanonical
<https://en.wikipedia.org/wiki/Microcanonical_ensemble>`_ versions of
these distributions that are asymptotically equivalent, as described in
[peixoto-weighted-2017]_. These can be combined with arbitrary weight
transformations to achieve a large family of associated
distributions. For example, to use a `log-normal
<https://en.wikipedia.org/wiki/Log-normal_distribution>`_ weight model
for positive real weights :math:`\boldsymbol x`, we can use the
transformation :math:`y_{ij} = \ln x_{ij}` together with the
``"real-normal"`` model for :math:`\boldsymbol y`. To model weights that
are positive or negative integers in :math:`\mathbb{Z}`, we could either
subtract the minimum value, :math:`y_{ij} = x_{ij} - x^*`, with
:math:`x^*=\operatorname{min}_{ij}x_{ij}`, and use any of the above
models for non-negative integers in :math:`\mathbb{N}`, or
alternatively, consider the sign as an additional covariate,
i.e. :math:`s_{ij} = [\operatorname{sign}(x_{ij})+1]/2 \in \{0,1\}`,
using the Binomial distribution with :math:`M=1` (a.k.a. the `Bernoulli
distribution <https://en.wikipedia.org/wiki/Bernoulli_distribution>`_),
and any of the other discrete distributions for the magnitude,
:math:`y_{ij} = \operatorname{abs}(x_{ij})`.
   
The support for weighted networks is activated by passing the parameters
``recs`` and ``rec_types`` to :class:`~graph_tool.inference.BlockState`
(or :class:`~graph_tool.inference.OverlapBlockState`), that specify the
edge covariates (an edge :class:`~graph_tool.PropertyMap`) and their
types (a string from the table above), respectively. Note that these
parameters expect *lists*, so that multiple edge weights can be used
simultaneously.

For example, let us consider a network of suspected terrorists involved
in the train bombing of Madrid on March 11, 2004
[hayes-connecting-2006]_. An edge indicates that a connection between
the two persons have been identified, and the weight of the edge (an
integer in the range :math:`[0,3]`) indicates the "strength" of the
connection. We can apply the weighted SBM, using a Binomial model for
the weights, as follows:


.. testsetup:: weighted-model

   import os
   try:
       os.chdir("demos/inference")
   except FileNotFoundError:
       pass
   gt.seed_rng(42)
         
.. testcode:: weighted-model

   g = gt.collection.konect_data["moreno_train"]

   # This network contains an internal edge property map with name
   # "weight" that contains the strength of interactions. The values
   # integers in the range [0, 3].
   
   state = gt.minimize_nested_blockmodel_dl(g, state_args=dict(recs=[g.ep.weight],
                                                               rec_types=["discrete-binomial"]))

   state.draw(edge_color=g.ep.weight, ecmap=(matplotlib.cm.inferno, .6),
              eorder=g.ep.weight, edge_pen_width=gt.prop_to_size(g.ep.weight, 1, 4, power=1),
              edge_gradient=[], output="moreno-train-wsbm.svg")

.. figure:: moreno-train-wsbm.*
   :align: center
   :width: 350px

   Best fit of the Binomial-weighted degree-corrected SBM for a network
   of terror suspects, using the strength of connection as edge
   covariates. The edge colors and widths correspond to the strengths.

Model selection
+++++++++++++++

In order to select the best weighted model, we proceed in the same
manner as described in Sec. :ref:`model_selection`. However, when using
transformations on continuous weights, we must include the associated
scaling of the probability density, as described in
[peixoto-weighted-2017]_.

For example, consider a `food web
<https://en.wikipedia.org/wiki/Food_web>`_ between species in south
Florida [ulanowicz-network-2005]_. A directed link exists from species
:math:`i` to :math:`j` if a biomass flow exists between them, and a
weight :math:`x_{ij}` on this edge indicates the magnitude of biomass
flow (a positive real value, i.e. :math:`x_{ij}\in [0,\infty]`). One
possibility, therefore, is to use the ``"real-exponential"`` model, as
follows:

.. testsetup:: food-web

   import os
   try:
       os.chdir("demos/inference")
   except FileNotFoundError:
       pass
   gt.seed_rng(44)
         
.. testcode:: food-web

   g = gt.collection.konect_data["foodweb-baywet"]

   # This network contains an internal edge property map with name
   # "weight" that contains the biomass flow between species. The values
   # are continuous in the range [0, infinity].
   
   state = gt.minimize_nested_blockmodel_dl(g, state_args=dict(recs=[g.ep.weight],
                                                               rec_types=["real-exponential"]))

   state.draw(edge_color=gt.prop_to_size(g.ep.weight, power=1, log=True), ecmap=(matplotlib.cm.inferno, .6),
              eorder=g.ep.weight, edge_pen_width=gt.prop_to_size(g.ep.weight, 1, 4, power=1, log=True),
              edge_gradient=[], output="foodweb-wsbm.svg")

.. figure:: foodweb-wsbm.*
   :align: center
   :width: 350px

   Best fit of the exponential-weighted degree-corrected SBM for a food
   web, using the biomass flow as edge covariates (indicated by the edge
   colors and widths).

Alternatively, we may consider a transformation of the type

.. math::
   :label: log_transform

   y_{ij} = \ln x_{ij}

so that :math:`y_{ij} \in [-\infty,\infty]`. If we use a model
``"real-normal"`` for :math:`\boldsymbol y`, it amounts to a `log-normal
<https://en.wikipedia.org/wiki/Log-normal_distribution>`_ model for
:math:`\boldsymbol x`. This can be a better choice if the weights are
distributed across many orders of magnitude, or show multi-modality. We
can fit this alternative model simply by using the transformed weights:

.. testcode:: food-web

   # Apply the weight transformation
   y = g.ep.weight.copy()
   y.a = log(y.a)
   
   state_ln = gt.minimize_nested_blockmodel_dl(g, state_args=dict(recs=[y],
                                                                  rec_types=["real-normal"]))

   state_ln.draw(edge_color=gt.prop_to_size(g.ep.weight, power=1, log=True), ecmap=(matplotlib.cm.inferno, .6),
                 eorder=g.ep.weight, edge_pen_width=gt.prop_to_size(g.ep.weight, 1, 4, power=1, log=True),
                 edge_gradient=[], output="foodweb-wsbm-lognormal.svg")

.. figure:: foodweb-wsbm-lognormal.*
   :align: center
   :width: 350px

   Best fit of the log-normal-weighted degree-corrected SBM for a food
   web, using the biomass flow as edge covariates (indicated by the edge
   colors and widths).

At this point, we ask ourselves which of the above models yields the
best fit of the data. This is answered by performing model selection via
posterior odds ratios just like in Sec. :ref:`model_selection`. However,
here we need to take into account the scaling of the probability density
incurred by the variable transformation, i.e.

.. math::

    P(\boldsymbol x | \boldsymbol G, \boldsymbol b) =
    P(\boldsymbol y(\boldsymbol x) | \boldsymbol G, \boldsymbol b)
    \prod_{ij}\left[\frac{\mathrm{d}y_{ij}}{\mathrm{d}x_{ij}}(x_{ij})\right]^{A_{ij}}.

In the particular case of Eq. :eq:`log_transform`, we have

.. math::

    \prod_{ij}\left[\frac{\mathrm{d}y_{ij}}{\mathrm{d}x_{ij}}(x_{ij})\right]^{A_{ij}}
    = \prod_{ij}\frac{1}{x_{ij}^{A_{ij}}}.

Therefore, we can compute the posterior odds ratio between both models as:

.. testcode:: food-web

   L1 = -state.entropy()
   L2 = -state_ln.entropy() - log(g.ep.weight.a).sum()
              
   print(u"ln \u039b: ", L2 - L1)

.. testoutput:: food-web
   :options: +NORMALIZE_WHITESPACE

   ln Λ:  -43.189790...

A value of :math:`\Lambda \approx \mathrm{e}^{-43} \approx 10^{-19}` in
favor the exponential model indicates that the log-normal model does not
provide a better fit for this particular data. Based on this, we
conclude that the exponential model should be preferred in this case.
   
   
Posterior sampling
++++++++++++++++++
   
The procedure to sample from the posterior distribution is identical to
what is described in Sec. :ref:`sampling`, but with the appropriate
initialization, i.e.

.. testcode:: weighted-model

    state = gt.BlockState(g, B=20, recs=[g.ep.weight], rec_types=["discrete-poisson"])

or for the nested model

.. testcode:: weighted-model

    state = gt.NestedBlockState(g, bs=[np.random.randint(0, 20, g.num_vertices())] + [zeros(1)] * 10,
                                state_args=dict(recs=[g.ep.weight],
                                                rec_types=["discrete-poisson"]))

Layered networks
----------------

The edges of the network may be distributed in discrete "layers",
representing distinct types if interactions
[peixoto-inferring-2015]_. Extensions to the SBM may be defined for such
data, and they can be inferred using the exact same interface shown
above, except one should use the
:class:`~graph_tool.inference.LayeredBlockState` class, instead of
:class:`~graph_tool.inference.BlockState`. This class takes two
additional parameters: the ``ec`` parameter, that must correspond to an
edge :class:`~graph_tool.PropertyMap` with the layer/covariate values on
the edges, and the Boolean ``layers`` parameter, which if ``True``
specifies a layered model, otherwise one with categorical edge
covariates (not to be confused with the weighted models in
Sec. :ref:`weights`).

If we use :func:`~graph_tool.inference.minimize_blockmodel_dl`, this can
be achieved simply by passing the option ``layers=True`` as well as the
appropriate value of ``state_args``, which will be propagated to
:class:`~graph_tool.inference.LayeredBlockState`'s constructor.

As an example, let us consider a social network of tribes, where two
types of interactions were recorded, amounting to either friendship or
enmity [read-cultures-1954]_. We may apply the layered model by
separating these two types of interactions in two layers:

.. testsetup:: layered-model

   import os
   try:
       os.chdir("demos/inference")
   except FileNotFoundError:
       pass
   gt.seed_rng(42)
         
.. testcode:: layered-model

   g = gt.collection.konect_data["ucidata-gama"]

   # The edge types are stored in the edge property map "weights".

   # Note the different meanings of the two 'layers' parameters below: The
   # first enables the use of LayeredBlockState, and the second selects
   # the 'edge layers' version (instead of 'edge covariates').

   state = gt.minimize_nested_blockmodel_dl(g, layers=True,
                                            state_args=dict(ec=g.ep.weight, layers=True))

   state.draw(edge_color=g.ep.weight, edge_gradient=[],
              ecmap=(matplotlib.cm.coolwarm_r, .6), edge_pen_width=5,
              output="tribes-sbm-edge-layers.svg")

.. figure:: tribes-sbm-edge-layers.*
   :align: center
   :width: 350px

   Best fit of the degree-corrected SBM with edge layers for a network
   of tribes, with edge layers shown as colors. The groups show two
   enemy tribes.

It is possible to perform model averaging of all layered variants
exactly like for the regular SBMs as was shown above.

Predicting spurious and missing edges
-------------------------------------

An important application of generative models is to be able to
generalize from observations and make predictions that go beyond what
is seen in the data. This is particularly useful when the network we
observe is incomplete, or contains errors, i.e. some of the edges are
either missing or are outcomes of mistakes in measurement. In this
situation, the fit we make of the observed network can help us
predict missing or spurious edges in the network
[clauset-hierarchical-2008]_ [guimera-missing-2009]_.

We do so by dividing the edges into two sets :math:`\boldsymbol G` and
:math:`\delta \boldsymbol G`, where the former corresponds to the
observed network and the latter either to the missing or spurious
edges. We may compute the posterior of :math:`\delta \boldsymbol G` as
[valles-catala-consistency-2017]_

.. math::
   :label: posterior-missing

   P(\delta \boldsymbol G | \boldsymbol G) \propto
   \sum_{\boldsymbol b}\frac{P(\boldsymbol G \cup \delta\boldsymbol G| \boldsymbol b)}{P(\boldsymbol G| \boldsymbol b)}P(\boldsymbol b | \boldsymbol G)

up to a normalization constant. Although the normalization constant is
difficult to obtain in general (since we need to perform a sum over all
possible spurious/missing edges), the numerator of
Eq. :eq:`posterior-missing` can be computed by sampling partitions from
the posterior, and then inserting or deleting edges from the graph and
computing the new likelihood. This means that we can easily compare
alternative predictive hypotheses :math:`\{\delta \boldsymbol G_i\}` via
their likelihood ratios

.. math::

   \lambda_i = \frac{P(\delta \boldsymbol G_i | \boldsymbol G)}{\sum_j P(\delta \boldsymbol G_j | \boldsymbol G)}

which do not depend on the normalization constant.

The values :math:`P(\delta \boldsymbol G | \boldsymbol G, \boldsymbol b)`
can be computed with
:meth:`~graph_tool.inference.BlockState.get_edges_prob`. Hence, we can
compute spurious/missing edge probabilities just as if we were
collecting marginal distributions when doing model averaging.

Below is an example for predicting the two following edges in the
football network, using the nested model (for which we need to replace
:math:`\boldsymbol b` by :math:`\{\boldsymbol b_l\}` in the equations
above).

.. testcode:: missing-edges
   :hide:

   import os
   try:
      os.chdir("demos/inference")
   except FileNotFoundError:
       pass

   g = gt.collection.data["football"].copy()
   color = g.new_vp("string", val="#cccccc")
   ecolor = g.new_ep("string", val="#cccccc")
   ewidth = g.new_ep("double", 1)
   e = g.add_edge(101, 102)
   ecolor[e] = "#a40000"
   ewidth[e] = 5
   e = g.add_edge(17, 56)
   ecolor[e] = "#a40000"
   ewidth[e] = 5
   eorder = g.edge_index.copy("int")

   gt.graph_draw(g, pos=g.vp.pos, vertex_color=color,
                 vertex_fill_color=color, edge_color=ecolor,
                 eorder=eorder, edge_pen_width=ewidth,
                 output="football_missing.svg")

.. figure:: football_missing.*
   :align: center
   :width: 350px

   Two non-existing edges in the football network (in red):
   :math:`(101,102)` in the middle, and :math:`(17,56)` in the upper
   right region of the figure.

.. testsetup:: missing-edges

   gt.seed_rng(7)

.. testcode:: missing-edges

   g = gt.collection.data["football"]

   missing_edges = [(101, 102), (17, 56)]
   
   L = 10

   state = gt.minimize_nested_blockmodel_dl(g, deg_corr=True)

   bs = state.get_bs()                     # Get hierarchical partition.
   bs += [np.zeros(1)] * (L - len(bs))     # Augment it to L = 10 with
                                           # single-group levels.

   state = state.copy(bs=bs, sampling=True)

   probs = ([], [])

   def collect_edge_probs(s):
       p1 = s.get_edges_prob([missing_edges[0]], entropy_args=dict(partition_dl=False))
       p2 = s.get_edges_prob([missing_edges[1]], entropy_args=dict(partition_dl=False))
       probs[0].append(p1)
       probs[1].append(p2)

   # Now we collect the probabilities for exactly 100,000 sweeps
   gt.mcmc_equilibrate(state, force_niter=10000, mcmc_args=dict(niter=10),
                       callback=collect_edge_probs)


   def get_avg(p):
      p = np.array(p)
      pmax = p.max()
      p -= pmax
      return pmax + log(exp(p).mean())

   p1 = get_avg(probs[0])
   p2 = get_avg(probs[1])

   p_sum = get_avg([p1, p2]) + log(2)
   
   l1 = p1 - p_sum
   l2 = p2 - p_sum

   print("likelihood-ratio for %s: %g" % (missing_edges[0], exp(l1)))
   print("likelihood-ratio for %s: %g" % (missing_edges[1], exp(l2)))


.. testoutput:: missing-edges

   likelihood-ratio for (101, 102): 0.36...
   likelihood-ratio for (17, 56): 0.63...

From which we can conclude that edge :math:`(17, 56)` is more likely
than :math:`(101, 102)` to be a missing edge.

The prediction using the non-nested model can be performed in an
entirely analogous fashion.

References
----------

.. [peixoto-bayesian-2017] Tiago P. Peixoto, "Bayesian stochastic blockmodeling",
   :arxiv:`1705.10225`

.. [holland-stochastic-1983] Paul W. Holland, Kathryn Blackmond Laskey,
   Samuel Leinhardt, "Stochastic blockmodels: First steps", Social Networks
   Volume 5, Issue 2, Pages 109-137 (1983). :doi:`10.1016/0378-8733(83)90021-7`

.. [karrer-stochastic-2011] Brian Karrer, M. E. J. Newman "Stochastic
   blockmodels and community structure in networks", Phys. Rev. E 83,
   016107 (2011). :doi:`10.1103/PhysRevE.83.016107`, :arxiv:`1008.3926`
   
.. [peixoto-nonparametric-2017] Tiago P. Peixoto, "Nonparametric
   Bayesian inference of the microcanonical stochastic block model",
   Phys. Rev. E 95 012317 (2017). :doi:`10.1103/PhysRevE.95.012317`,
   :arxiv:`1610.02703`

.. [peixoto-parsimonious-2013] Tiago P. Peixoto, "Parsimonious module
   inference in large networks", Phys. Rev. Lett. 110, 148701 (2013).
   :doi:`10.1103/PhysRevLett.110.148701`, :arxiv:`1212.4794`.

.. [peixoto-hierarchical-2014] Tiago P. Peixoto, "Hierarchical block
   structures and high-resolution model selection in large networks",
   Phys. Rev. X 4, 011047 (2014). :doi:`10.1103/PhysRevX.4.011047`,
   :arxiv:`1310.4377`.

.. [peixoto-model-2016] Tiago P. Peixoto, "Model selection and hypothesis
   testing for large-scale network models with overlapping groups",
   Phys. Rev. X 5, 011033 (2016). :doi:`10.1103/PhysRevX.5.011033`,
   :arxiv:`1409.3059`.

.. [peixoto-inferring-2015] Tiago P. Peixoto, "Inferring the mesoscale
   structure of layered, edge-valued and time-varying networks",
   Phys. Rev. E 92, 042807 (2015). :doi:`10.1103/PhysRevE.92.042807`,
   :arxiv:`1504.02381`

.. [aicher-learning-2015] Christopher Aicher, Abigail Z. Jacobs, and
   Aaron Clauset, "Learning Latent Block Structure in Weighted
   Networks", Journal of Complex Networks 3(2). 221-248
   (2015). :doi:`10.1093/comnet/cnu026`, :arxiv:`1404.0431`

.. [peixoto-weighted-2017] Tiago P. Peixoto, "Nonparametric weighted
   stochastic block models", :arxiv:`1708.01432`
          
.. [peixoto-efficient-2014] Tiago P. Peixoto, "Efficient Monte Carlo and
   greedy heuristic for the inference of stochastic block models", Phys.
   Rev. E 89, 012804 (2014). :doi:`10.1103/PhysRevE.89.012804`,
   :arxiv:`1310.4378`

.. [clauset-hierarchical-2008] Aaron Clauset, Cristopher
   Moore, M. E. J. Newman, "Hierarchical structure and the prediction of
   missing links in networks", Nature 453, 98-101 (2008).
   :doi:`10.1038/nature06830`

.. [guimera-missing-2009] Roger Guimerà, Marta Sales-Pardo, "Missing and
   spurious interactions and the reconstruction of complex networks", PNAS
   vol. 106 no. 52 (2009). :doi:`10.1073/pnas.0908366106`
          
.. [valles-catala-consistency-2017] Toni Vallès-Català,
   Tiago P. Peixoto, Roger Guimerà, Marta Sales-Pardo, "On the consistency
   between model selection and link prediction in networks". :arxiv:`1705.07967`

.. [mezard-information-2009] Marc Mézard, Andrea Montanari, "Information,
   Physics, and Computation", Oxford Univ Press (2009).
   :DOI:`10.1093/acprof:oso/9780198570837.001.0001`

.. [guimera-modularity-2004] Roger Guimerà, Marta Sales-Pardo, and
   Luís A. Nunes Amaral, "Modularity from fluctuations in random graphs
   and complex networks", Phys. Rev. E 70, 025101(R) (2004),
   :doi:`10.1103/PhysRevE.70.025101`

.. [hayes-connecting-2006] Brian Hayes, "Connecting the dots. can the
   tools of graph theory and social-network studies unravel the next big
   plot?", American Scientist, 94(5):400-404, 2006.
   http://www.jstor.org/stable/27858828

.. [ulanowicz-network-2005] Robert E. Ulanowicz, and
   Donald L. DeAngelis. "Network analysis of trophic dynamics in south
   florida ecosystems." US Geological Survey Program on the South
   Florida Ecosystem 114 (2005).
   https://fl.water.usgs.gov/PDF_files/ofr99_181_gerould.pdf#page=125

.. [read-cultures-1954] Kenneth E. Read, "Cultures of the Central
   Highlands, New Guinea", Southwestern J. of Anthropology,
   10(1):1-43 (1954). :doi:`10.1086/soutjanth.10.1.3629074`
